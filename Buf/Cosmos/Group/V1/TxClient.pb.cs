// <auto-generated>
//    Code generated by protoc-gen-cosmos-csharp plugin.  DO NOT EDIT!
//    The plugin is part of the DecentralCardGame project and written by lxgr@protonmail.com
//    source: cosmos/group/v1/tx.proto
// </auto-generated>
#nullable enable

using System;
using Cosmcs.Client;
using Cosmcs.Tx;
using System.Threading.Tasks;
using Google.Protobuf.WellKnownTypes;
using Google.Protobuf;

namespace Cosmos.Group.V1 {
	
	public class MsgClient {
		public IClient Client { get; }

		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public MsgClient (IClient client) {
			Client = client;
		}
        
        /// <summary>
      	/// SendMsgCreateGroup sends a MsgCreateGroup transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroup message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCreateGroupResponse>> SendMsgCreateGroup(MsgCreateGroup msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgCreateGroup"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCreateGroupResponse>(
				r.Result,
				MsgCreateGroupResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCreateGroup simulates a MsgCreateGroup transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroup message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCreateGroup(MsgCreateGroup msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgCreateGroup"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCreateGroup simulates, estimates fees and then sends a CreateGroup transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroup message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCreateGroupResponse>> SimulateAndSendMsgCreateGroup(MsgCreateGroup msg) {
			return SimulateMsgCreateGroup(msg).ContinueWith(r => {
				return SendMsgCreateGroup(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgUpdateGroupMembers sends a MsgUpdateGroupMembers transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupMembers message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupMembersResponse>> SendMsgUpdateGroupMembers(MsgUpdateGroupMembers msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupMembers"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUpdateGroupMembersResponse>(
				r.Result,
				MsgUpdateGroupMembersResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUpdateGroupMembers simulates a MsgUpdateGroupMembers transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupMembers message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUpdateGroupMembers(MsgUpdateGroupMembers msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupMembers"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUpdateGroupMembers simulates, estimates fees and then sends a UpdateGroupMembers transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupMembers message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupMembersResponse>> SimulateAndSendMsgUpdateGroupMembers(MsgUpdateGroupMembers msg) {
			return SimulateMsgUpdateGroupMembers(msg).ContinueWith(r => {
				return SendMsgUpdateGroupMembers(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgUpdateGroupAdmin sends a MsgUpdateGroupAdmin transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupAdmin message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupAdminResponse>> SendMsgUpdateGroupAdmin(MsgUpdateGroupAdmin msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupAdmin"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUpdateGroupAdminResponse>(
				r.Result,
				MsgUpdateGroupAdminResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUpdateGroupAdmin simulates a MsgUpdateGroupAdmin transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupAdmin message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUpdateGroupAdmin(MsgUpdateGroupAdmin msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupAdmin"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUpdateGroupAdmin simulates, estimates fees and then sends a UpdateGroupAdmin transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupAdmin message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupAdminResponse>> SimulateAndSendMsgUpdateGroupAdmin(MsgUpdateGroupAdmin msg) {
			return SimulateMsgUpdateGroupAdmin(msg).ContinueWith(r => {
				return SendMsgUpdateGroupAdmin(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgUpdateGroupMetadata sends a MsgUpdateGroupMetadata transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupMetadata message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupMetadataResponse>> SendMsgUpdateGroupMetadata(MsgUpdateGroupMetadata msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupMetadata"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUpdateGroupMetadataResponse>(
				r.Result,
				MsgUpdateGroupMetadataResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUpdateGroupMetadata simulates a MsgUpdateGroupMetadata transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupMetadata message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUpdateGroupMetadata(MsgUpdateGroupMetadata msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupMetadata"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUpdateGroupMetadata simulates, estimates fees and then sends a UpdateGroupMetadata transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupMetadata message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupMetadataResponse>> SimulateAndSendMsgUpdateGroupMetadata(MsgUpdateGroupMetadata msg) {
			return SimulateMsgUpdateGroupMetadata(msg).ContinueWith(r => {
				return SendMsgUpdateGroupMetadata(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCreateGroupPolicy sends a MsgCreateGroupPolicy transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroupPolicy message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCreateGroupPolicyResponse>> SendMsgCreateGroupPolicy(MsgCreateGroupPolicy msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgCreateGroupPolicy"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCreateGroupPolicyResponse>(
				r.Result,
				MsgCreateGroupPolicyResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCreateGroupPolicy simulates a MsgCreateGroupPolicy transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroupPolicy message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCreateGroupPolicy(MsgCreateGroupPolicy msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgCreateGroupPolicy"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCreateGroupPolicy simulates, estimates fees and then sends a CreateGroupPolicy transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroupPolicy message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCreateGroupPolicyResponse>> SimulateAndSendMsgCreateGroupPolicy(MsgCreateGroupPolicy msg) {
			return SimulateMsgCreateGroupPolicy(msg).ContinueWith(r => {
				return SendMsgCreateGroupPolicy(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCreateGroupWithPolicy sends a MsgCreateGroupWithPolicy transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroupWithPolicy message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCreateGroupWithPolicyResponse>> SendMsgCreateGroupWithPolicy(MsgCreateGroupWithPolicy msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgCreateGroupWithPolicy"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCreateGroupWithPolicyResponse>(
				r.Result,
				MsgCreateGroupWithPolicyResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCreateGroupWithPolicy simulates a MsgCreateGroupWithPolicy transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroupWithPolicy message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCreateGroupWithPolicy(MsgCreateGroupWithPolicy msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgCreateGroupWithPolicy"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCreateGroupWithPolicy simulates, estimates fees and then sends a CreateGroupWithPolicy transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCreateGroupWithPolicy message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCreateGroupWithPolicyResponse>> SimulateAndSendMsgCreateGroupWithPolicy(MsgCreateGroupWithPolicy msg) {
			return SimulateMsgCreateGroupWithPolicy(msg).ContinueWith(r => {
				return SendMsgCreateGroupWithPolicy(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgUpdateGroupPolicyAdmin sends a MsgUpdateGroupPolicyAdmin transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyAdmin message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyAdminResponse>> SendMsgUpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyAdminResponse>(
				r.Result,
				MsgUpdateGroupPolicyAdminResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUpdateGroupPolicyAdmin simulates a MsgUpdateGroupPolicyAdmin transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyAdmin message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUpdateGroupPolicyAdmin simulates, estimates fees and then sends a UpdateGroupPolicyAdmin transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyAdmin message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyAdminResponse>> SimulateAndSendMsgUpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin msg) {
			return SimulateMsgUpdateGroupPolicyAdmin(msg).ContinueWith(r => {
				return SendMsgUpdateGroupPolicyAdmin(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgUpdateGroupPolicyDecisionPolicy sends a MsgUpdateGroupPolicyDecisionPolicy transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyDecisionPolicy message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyDecisionPolicyResponse>> SendMsgUpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyDecisionPolicyResponse>(
				r.Result,
				MsgUpdateGroupPolicyDecisionPolicyResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUpdateGroupPolicyDecisionPolicy simulates a MsgUpdateGroupPolicyDecisionPolicy transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyDecisionPolicy message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUpdateGroupPolicyDecisionPolicy simulates, estimates fees and then sends a UpdateGroupPolicyDecisionPolicy transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyDecisionPolicy message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyDecisionPolicyResponse>> SimulateAndSendMsgUpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy msg) {
			return SimulateMsgUpdateGroupPolicyDecisionPolicy(msg).ContinueWith(r => {
				return SendMsgUpdateGroupPolicyDecisionPolicy(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgUpdateGroupPolicyMetadata sends a MsgUpdateGroupPolicyMetadata transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyMetadata message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyMetadataResponse>> SendMsgUpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyMetadataResponse>(
				r.Result,
				MsgUpdateGroupPolicyMetadataResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUpdateGroupPolicyMetadata simulates a MsgUpdateGroupPolicyMetadata transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyMetadata message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUpdateGroupPolicyMetadata simulates, estimates fees and then sends a UpdateGroupPolicyMetadata transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateGroupPolicyMetadata message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUpdateGroupPolicyMetadataResponse>> SimulateAndSendMsgUpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata msg) {
			return SimulateMsgUpdateGroupPolicyMetadata(msg).ContinueWith(r => {
				return SendMsgUpdateGroupPolicyMetadata(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSubmitProposal sends a MsgSubmitProposal transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSubmitProposal message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSubmitProposalResponse>> SendMsgSubmitProposal(MsgSubmitProposal msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgSubmitProposal"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSubmitProposalResponse>(
				r.Result,
				MsgSubmitProposalResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSubmitProposal simulates a MsgSubmitProposal transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSubmitProposal message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSubmitProposal(MsgSubmitProposal msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgSubmitProposal"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSubmitProposal simulates, estimates fees and then sends a SubmitProposal transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSubmitProposal message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSubmitProposalResponse>> SimulateAndSendMsgSubmitProposal(MsgSubmitProposal msg) {
			return SimulateMsgSubmitProposal(msg).ContinueWith(r => {
				return SendMsgSubmitProposal(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgWithdrawProposal sends a MsgWithdrawProposal transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgWithdrawProposal message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgWithdrawProposalResponse>> SendMsgWithdrawProposal(MsgWithdrawProposal msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgWithdrawProposal"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgWithdrawProposalResponse>(
				r.Result,
				MsgWithdrawProposalResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgWithdrawProposal simulates a MsgWithdrawProposal transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgWithdrawProposal message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgWithdrawProposal(MsgWithdrawProposal msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgWithdrawProposal"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgWithdrawProposal simulates, estimates fees and then sends a WithdrawProposal transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgWithdrawProposal message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgWithdrawProposalResponse>> SimulateAndSendMsgWithdrawProposal(MsgWithdrawProposal msg) {
			return SimulateMsgWithdrawProposal(msg).ContinueWith(r => {
				return SendMsgWithdrawProposal(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgVote sends a MsgVote transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgVote message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgVoteResponse>> SendMsgVote(MsgVote msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgVote"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgVoteResponse>(
				r.Result,
				MsgVoteResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgVote simulates a MsgVote transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgVote message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgVote(MsgVote msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgVote"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgVote simulates, estimates fees and then sends a Vote transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgVote message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgVoteResponse>> SimulateAndSendMsgVote(MsgVote msg) {
			return SimulateMsgVote(msg).ContinueWith(r => {
				return SendMsgVote(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgExec sends a MsgExec transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgExec message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgExecResponse>> SendMsgExec(MsgExec msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgExec"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgExecResponse>(
				r.Result,
				MsgExecResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgExec simulates a MsgExec transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgExec message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgExec(MsgExec msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgExec"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgExec simulates, estimates fees and then sends a Exec transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgExec message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgExecResponse>> SimulateAndSendMsgExec(MsgExec msg) {
			return SimulateMsgExec(msg).ContinueWith(r => {
				return SendMsgExec(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgLeaveGroup sends a MsgLeaveGroup transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgLeaveGroup message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgLeaveGroupResponse>> SendMsgLeaveGroup(MsgLeaveGroup msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgLeaveGroup"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgLeaveGroupResponse>(
				r.Result,
				MsgLeaveGroupResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgLeaveGroup simulates a MsgLeaveGroup transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgLeaveGroup message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgLeaveGroup(MsgLeaveGroup msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cosmos.group.v1.MsgLeaveGroup"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgLeaveGroup simulates, estimates fees and then sends a LeaveGroup transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgLeaveGroup message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgLeaveGroupResponse>> SimulateAndSendMsgLeaveGroup(MsgLeaveGroup msg) {
			return SimulateMsgLeaveGroup(msg).ContinueWith(r => {
				return SendMsgLeaveGroup(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
	}
	
}
